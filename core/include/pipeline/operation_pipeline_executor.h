/**
 * @file operation_pipeline_executor.h
 * @brief Declaration of OperationPipelineExecutor, a concrete implementation of IPipelineExecutor for adjustment operations.
 * @author CaptureMoment Team
 * @date 2026
 */

#pragma once

#include "pipeline/interfaces/i_pipeline_executor.h"
#include "image_processing/interfaces/i_working_image_hardware.h"
#include "operations/operation_descriptor.h"
#include "operations/operation_factory.h"

#include <vector>
#include <memory>

#include <Halide.h>

namespace CaptureMoment::Core {

namespace Pipeline {

/**
 * @brief Concrete implementation of IPipelineExecutor for executing fused adjustment operation pipelines.
 *
 * OperationPipelineExecutor encapsulates a compiled Halide pipeline for image adjustments
 * and provides the method to execute it on a given IWorkingImageHardware.
 * It inherits from IPipelineExecutor, fulfilling the contract for pipeline execution.
 * 
 * Note: This class is intended to be instantiated by OperationPipelineBuilder.
 * Direct instantiation from user code is not typically required.
 * 
 * This class stores a compiled Halide pipeline in m_compiled_pipeline to optimize
 * repeated executions. The pipeline is rebuilt and recompiled only when the list
 * of operations changes, not when just the parameters of existing operations change.
 * This significantly improves performance for interactive adjustments.
 */
class OperationPipelineExecutor final : public IPipelineExecutor {
public:
    /**
     * @brief Constructor that takes the operations and factory needed to build the fused pipeline.
     * @param operations The list of operation descriptors to be fused.
     * @param factory The operation factory to retrieve fusion logic implementations.
     */
    explicit OperationPipelineExecutor(
        const std::vector<Operations::OperationDescriptor>& operations,
        const Operations::OperationFactory& factory
        );

    /**
     * @brief Executes the pre-built fused adjustment pipeline on the given image.
     *
     * Implements the execute method from IPipelineExecutor.
     * This method runs the specific fused Halide pipeline logic for adjustments
     * on the provided working_image. The pipeline is compiled once upon construction
     * and reused for subsequent executions, unless the operation list changes.
     *
     * @param[in,out] working_image The hardware-agnostic image buffer to process.
     *                              The image is modified in-place by the fused adjustment pipeline.
     * @return true if the execution was successful, false otherwise
     *         (e.g., runtime error during execution).
     */
    [[nodiscard]] bool execute(ImageProcessing::IWorkingImageHardware& working_image) const override;

private:
    /**
     * @brief Stores the list of operation descriptors to be fused into the pipeline.
     * 
     * This member holds the sequence of operations that will be combined into a single
     * computational pass. It is captured during construction and used by the compilePipeline
     * method to build the Halide pipeline. Changes to this list trigger a pipeline rebuild.
     */
    std::vector<Operations::OperationDescriptor> m_operations;
    
    /**
     * @brief Stores the operation factory used to create instances of operations for fusion.
     * 
     * This member holds a reference to the factory object that can instantiate concrete
     * operation classes implementing IOperationFusionLogic. It is used during pipeline
     * compilation to retrieve the necessary fusion fragments from each operation.
     */
    Operations::OperationFactory m_factory;
    
    /**
     * @brief Stores the compiled Halide pipeline for efficient reuse. 
     * This member holds the compiled Halide::Pipeline object resulting from
     * the fusion of all operations. It is computed once during the construction
     * of the OperationPipelineExecutor and reused in the execute method.
     * This avoids the overhead of rebuilding and recompiling the pipeline
     * on every execution, significantly improving performance for repeated calls
     * with the same sequence of operations.
     * The Halide::Pipeline class represents a compiled Halide function that can
     * be executed on image data. It encapsulates the optimized computation graph
     * generated by the Halide compiler.
     */
    mutable std::unique_ptr<Halide::Pipeline> m_saved_pipeline;

    /**
     * @brief Builds and compiles the fused Halide pipeline for the stored operations.
     *  
     * This private helper method is called once during construction to
     * build the combined Halide function from all the operations in m_operations,
     * apply the appropriate scheduling based on the target backend, and compile
     * it into a Halide::Pipeline object stored in m_saved_pipeline.
     * This compilation step is computationally expensive and is therefore cached.
     */
    void savePipeline() const;
    
    /**
     * @brief Executes the pipeline using a concrete WorkingImageCPU_Halide or WorkingImageGPU_Halide implementation.
     *
     * This method is called when the working_image parameter can be cast to
     * a concrete Halide implementation (either CPU or GPU). It uses the internal
     * conversion methods of the concrete implementation to avoid intermediate copies.
     *
     * @param working_image The concrete WorkingImage implementation instance to process.
     * @return true if the execution was successful, false otherwise.
     */
    [[nodiscard]] bool executeWithConcreteImplementation(
        ImageProcessing::IWorkingImageHardware& working_image
        ) const;
    
    /**
     * @brief Executes the pipeline using a generic IWorkingImageHardware interface.
     * 
     * This method handles the case where the concrete implementation is unknown
     * and falls back to using exportToCPUCopy and updateFromCPU methods.
     * This may involve additional data copying compared to the concrete implementation path.
     * 
     * @param working_image The generic IWorkingImageHardware instance to process.
     * @return true if the execution was successful, false otherwise.
     */
    [[nodiscard]] bool executeGeneric(
        ImageProcessing::IWorkingImageHardware& working_image
        ) const;
};

} // namespace Pipeline

} // namespace CaptureMoment::Core
